<!DOCTYPE html>
<html>
  <head>
  
  <meta charset="UTF-8" />
  <title>数据类型的分析（一） - Frost</title>
  <meta name="referrer" content="no-referrer" />
  <link rel="shortcut icon" href="/static/img/icon.png">
  <link rel="icon" href="/static/img/icon.png" sizes="192x192" />

  
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">
 
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


  <meta
    name="viewport"
    content="width=device-width, maximum-scale=1, initial-scale=1"
  />
  <meta property="og:site_name" content="Frost" />
  <meta property="og:title" content="数据类型的分析（一）" />
  
  <style>
    body:before {
      content: "";
      background-image: url(https://api.paugram.com/wallpaper?source=gh);
    }
  </style>
  
<meta name="generator" content="Hexo 7.2.0"></head>

  <body>
    <header>
  <div class="head-title">
    <h4>Frost</h4>
  </div>
  <div class="head-action">
    <div class="toggle-btn"></div>
    <div class="light-btn"></div>
    <div class="search-btn"></div>
  </div>
  <form class="head-search" method="post">
    <input type="text" name="s" placeholder="搜索什么？" />
  </form>
  <nav class="head-menu">
    <a href="/">首页</a>
    <div class="has-child">
      <a>分类</a>
      <div class="sub-menu">
        <a class="category-link" href="/categories/shell/">shell</a><a class="category-link" href="/categories/%E5%AE%89%E5%8D%93/">安卓</a><a class="category-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
      </div>
    </div>
    
    <a href="/hyly">念念碎</a>
    
    <a href="/about">关于我</a>
    
  </nav>
</header>

    <main>
  <div class="wrap min">
    <section class="post-title">
      <h2>数据类型的分析（一）</h2>
      <div class="post-meta">
        <time class="date">2023.09.10</time>
        
        <span class="category"
          ><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span
        >
        
      </div>
    </section>
    <article class="post-content">
      
      <blockquote>
        这篇文章上次修改于 284 天前，可能其部分内容已经发生变化，如有疑问可询问作者。
      </blockquote>
       <p>数据结构概述<br>一、数据结构定义<br>如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找、删除某个元素，对所有元素排序）而执行的相应操作，这个操作也叫算法。<br>特定的数据类型: 个体元素<br>特定的存储结构：个体和个体之间的关系</p>
<p>数据结构&#x3D;个体+个体的关系<br>算法&#x3D;对存储数据的操作</p>
<p>二、算法定义<br>算法：解题的方法和步骤</p>
<p>三、 衡量算法的标准 1.时间复杂度<br>大概程序执行的次数，而非执行时间。 2.空间复杂度<br>算法执行过程中大概所占用的最大内存。 3.难易程度 4.健壮性</p>
<p>四、 数据结构的地位<br>数据结构是软件心中最核心的课程</p>
<p>程序&#x3D;数据结构+数据的操作+可以被计算机执行的语言</p>
<p>1.什么是堆？什么是栈？<br>很多人以为是内存里的 2 块儿空间，一块儿叫堆，一块叫栈，其实不对。实际上是指内存分配的方法不同的 2 种方式。如果是压栈出栈的方式分配和释放的内存就叫栈内存。如果是以堆排序分配的内存就叫堆内存。</p>
<p>**注意：数据结构里是没有堆这个概念的，堆是什么？是分配内存的一种方式，而不是存储数据的一种结构。</p>
<p>2.函数调用，如何调用呢？</p>
<p>压栈和出栈。</p>
<p>按时间存储的东西得有个顺序吧，按顺序存储的结构就是队列。<br>编译原理得学树。<br>数据库就是数据结构得简化版，讨论得问题差不多，解决得问题更狭窄了<br>程序&#x3D;数据的存储+数据的操作+可被计算机执行的语言。<br>数据结构很重要，难度大，学完很难做出东西来，学它是练内功。<br>五、预备知识 1.指针</p>
<p>指针的重要性<br>指针是 C 语言的灵魂</p>
<p>定义</p>
<p>地址<br>内存单元的编号<br>从 0 开始的非负整数<br>范围：0-FFFFFFFF【0~4G-1】<br>指针<br>指针就是地址，地址就是指针。<br>指针的本质是一个操作受限的非负整数</p>
<p>指针变量<br>指针变量是存放内存单元地址(编号)的变量</p>
<p>指针的分类 1.基本类型的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int *p; //p是个变量名字，int * 表示该P变量只能存储int类型变量的地址</span><br><span class="line">  int i = 10;</span><br><span class="line">  int j;</span><br><span class="line"></span><br><span class="line">  //（1）❌此时p还没有被赋值，里面是个垃圾值，这个垃圾值很可能正好是某个变量的地址</span><br><span class="line">  //所以应该在使用 *p 之前给p赋值地址：p = &amp;i;</span><br><span class="line">  j = *p;</span><br><span class="line"></span><br><span class="line">  //（2）❌ 给垃圾值地址的变量赋值一个新值，垃圾值应不受你控制的，随意改内存很危险 。</span><br><span class="line">  //若是 先写了p = &amp;i; 则下面等价于 i = i;</span><br><span class="line">  *p = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">change_arr(int *p, int len)</span><br><span class="line">&#123;</span><br><span class="line">  p[0] = -1; //p[0] = *(p + 0) = *p</span><br><span class="line">  p[2] = -9; //p[2] = *(p + 2) = *(a + 2) =     	a[2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">  printf(&quot;%d\n&quot;, a);</span><br><span class="line">  printf(&quot;%d\n&quot;, a + 1); //#####70      int型占4个字节</span><br><span class="line">  printf(&quot;%d\n&quot;, a + 2); //#####74</span><br><span class="line">  printf(&quot;%d\n&quot;, a + 3); //#####78</span><br><span class="line">  a + n = addr(a) + n * sizeof(typeof(a))</span><br><span class="line">                            change_arr(a, 5);</span><br><span class="line">  printf(&quot;%d\n&quot;, a[0]); // -1</span><br><span class="line">  printf(&quot;%d\n&quot;, a[2]); //-9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的指针变量只占 4 个字节，用第一个字节的地址表示整个变量的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  doueble arr[5] = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br><span class="line">  double *p = &amp;arr[0];</span><br><span class="line">  printf(&quot;%p\n&quot;, p); // %p以16进制的形式输出地址（012FF5C）</span><br><span class="line"></span><br><span class="line">  p = &amp;arr[1];</span><br><span class="line">  printf(&quot;%p\n&quot;, p); // %p以16进制的形式输出地址（012FF64）64-5C=8字节</span><br><span class="line">  //int 类型的话差4个，因为int 是4字节长度</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何通过函数修改实参的值<br>无论要通过函数改写什么类型的值，只需要传递它的地址就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i = 10;</span><br><span class="line">  int *p = &amp;i; // int * p; p = &amp; i;</span><br><span class="line">  printf(&quot;%p\n&quot;, p);</span><br><span class="line">  f(&amp;p);</span><br><span class="line">  printf(&quot;%p\n&quot;, p);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(int *q)</span><br><span class="line">&#123;</span><br><span class="line">  *q = (int *)0 x FFFFFFFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体使用概述 1.为什么需要结构体<br>为了表示一些复杂的数据，而普通的基本类型变量无法满足需求。</p>
<p>2.什么叫结构体<br>结构体是用户根据实际需要自己定义的复合数据类型。结构体给人感觉模拟事物模拟的不彻底（没有办法）但是仍然有好处；以算法为核心，血手结构。算法在面向过程的结构语言里最好。而面向对象的语言算法就不是其核心了。</p>
<p>3.如何使用结构体</p>
<p>两种方式：<br><code>struct Student st  = &#123;1000,&quot;LeeQiang&quot;,20&#125;;</code><br><code>struct Student  * pst  = &amp;st;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">＃include&lt;stdio.h&gt; struct Student</span><br><span class="line">&#123;</span><br><span class="line">  int sid;</span><br><span class="line">  char name[20];</span><br><span class="line">  int age;</span><br><span class="line">&#125;;</span><br><span class="line">int min(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct Student st = &#123;1,“LeeQiang” , 20&#125;;</span><br><span class="line">  printf(&quot;%d %s %d\n&quot;, st.sid, st.name, st.age);</span><br><span class="line">  //第一种访问方式</span><br><span class="line">  st.sid = 99;</span><br><span class="line">  // st.name = &quot;LeeSi&quot; // ❌error</span><br><span class="line">  strcpy(st.name, &quot;LeeSi&quot;);</span><br><span class="line">  st.age = 28;</span><br><span class="line">  printf(&quot;%d %s %d\n&quot;, st.sid, st.name, st.age);</span><br><span class="line"></span><br><span class="line">  struct Student *pst; //第二种方式最常用</span><br><span class="line">  pst = &amp;st;</span><br><span class="line">  pst-&gt;age = 22; // pst-&gt;age等价于 (*pst).age 而(*pst).age=st.age 所以pst-&gt;age = st.age;</span><br><span class="line">&#125; //这种方式好，因为只需要4个字节的参数变量</span><br><span class="line"></span><br><span class="line">void printStudent2(struct Student *st)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d %s %d\n&quot;, st.sid, st.name, st.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的 2 种变量方式<br><code>1.st.age</code><br><code>2.pst -&gt;age //pst 所指向的结构体变量中的age这个成员；</code></p>
<p>注意事项 1.结构体变量不能相互之间加减乘除，但能相互赋值。 2.普通结构体变量和结构体变量指针变量作为函数传参问题。</p>
<p>动态内存的分配和释放<br>假设构造一个 int 型的一维数组<br><code>int len; int * pArr = (int *)malloc(sizeof(int *)len)</code></p>
<p>本语句分配了两块内存，一块内存是动态分配的的总共 len 个字节；另一个是静态分配的，是 pArr 变量本身所占的内存总共 4 个字节。<br>malloc 只有一个 int 型的 形参，表示要求系统分配的字节数。<br>malloc 函数的功能是请求系统分配 len 个字节的内存空间，如果分配成功，则返回第一个字节。如果返回不成功，则返回 NULL。<br>malloc 函数能且只能返回第一个字节的地址，所以我们需要把这个无任何意义的第一个字节的地址(俗称干地址)转化为一个有实际意义的地址，因此，malloc 函数前面必须加强制类型转换(数据类型*)，表示把这个无实际意义的第一个字节的地址转化为相应类型的地址。<br>free(*pArr)表示把所指向的内存释放掉。pArr 本身的内存是静态的，不能由程序员手动释放，只能在 pArr 变量所在的函数运行终止时有系统自动释放。<br>跨函数使用内存<br>静态内存不可跨函数使用。</p>
<p>静态内存在函数执行期间可以被其他函数所使用。</p>
<p>静态内存在函数执行完毕之后就不能在被其他函数使用。</p>
<p>动态内存可以跨函数使用</p>
<p>动态内存在函数执行完毕之后仍可以被其他函数使用，除非使用 free()方法动态分配的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int a[5] = &#123;4, 10, 2, 8, 6&#125;;</span><br><span class="line">  int len;</span><br><span class="line">  printf(&quot;请输入需要分配的数组长度:len = &quot;);</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;len);</span><br><span class="line">  int *pArr = (int *)malloc(szieof(int *) len);</span><br><span class="line">  //* pArr = 4; //类似于 a[0] = 4;</span><br><span class="line">  // pArr[1] = 10; //类似于 a[1] = 10;</span><br><span class="line">  // printf(&quot;%d%d\n&quot;,*pArr,pArr[1]);</span><br><span class="line">  //我们可以把pARR 当做一个普通数组来使用</span><br><span class="line">  for (int i = 0; i &lt; len; ++i)</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;pArr[i]);</span><br><span class="line">  for (i = 0; i &lt; len; ++i;)</span><br><span class="line">      printf(&quot;%d\n&quot;, *(pArr + i));</span><br><span class="line">  free(pArr); // 把pArr所代表的动态分配的20个字节的内存释放</span><br><span class="line">  return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">  int sid;</span><br><span class="line">  int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Student *CreateStudent(void);</span><br><span class="line">void ShowStudent(struct Student *);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct Student *pS;</span><br><span class="line">  pS = CreateStudent();</span><br><span class="line">  ShowStudent(ps);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShowStudent(struct Student *pS)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d%d\n&quot;, pst-&gt;sid, pst-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Student *CreateStudent(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct Student *p = (struct Student *)malloc(sizeof(struct Student));</span><br><span class="line">  p-&gt;sid = 99;</span><br><span class="line">  p-&gt;age = 88;</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </article>
    <section class="post-near">
      <ul>
        
        <li>
          上一篇:
          <a href="/2023/09/10/2023-09-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95C%E8%AF%AD%E8%A8%80/">数据类型的分析（二）</a>
        </li>
         
        <li>
          下一篇:
          <a href="/2023/09/09/2023-09-09-shell%E8%84%9A%E6%9C%AC%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/">Shell脚本实现Base64 加密解密</a>
        </li>
        
      </ul>
    </section>

    
    <section class="post-tags">
      <a class="-none-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a><a class="-none-link" href="/tags/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" rel="tag">C语言指针</a><a class="-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a>
    </section>
    

    <script
      src="https://giscus.app/client.js"
      data-repo="XiaMuqingyuan/XiaMuqingyuan.github.io"
      data-repo-id="R_kgDOMI6vyA"
      data-category="General"
      data-category-id="DIC_kwDOMI6vyM4CgJja"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="preferred_color_scheme"
      data-lang="zh-CN"
      crossorigin="anonymous"
      async
    ></script>

    
    <section class="post-author">
      
      <figure class="author-avatar">
        <img src="https://files.cnblogs.com/files/blogs/808760/touxiang.gif?t=1700582933&download=true" alt="Frost" />
      </figure>
      
      <div class="author-info">
        <h4>Frost</h4>
        <p>恨君不似江楼月，南北东西，南北东西，只有相随无别离。</p>
      </div>
    </section>
    
  </div>
</main>

    <footer>
  <div class="buttons">
    <a class="to-top" href="#"></a>
  </div>
  <div class="wrap min">
    <section class="widget">
      <div class="row">
        <div class="col-m-4">
          <h3 class="title-recent">最新文章：</h3>
          <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/06/17/2024-06-17-Win11%E6%90%9C%E7%B4%A2%E6%A1%86%E6%81%A2%E5%A4%8D%E6%88%90%E6%94%BE%E5%A4%A7%E9%95%9C/">Windows11搜索框变大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/16/2024-06-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86/">二叉树四种遍历方法（C语言）</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/16/2024-06-16-%E8%A7%A3%E5%86%B3VUE%E6%89%93%E5%8C%85%E5%90%8E%E6%98%BE%E7%A4%BA%E4%B8%BA%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84%E6%96%B9%E6%B3%95/">解决vue打包后显示为空白页的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/11/2024-06-11-%E7%A7%BB%E5%8A%A8%E4%BA%91%E6%89%8B%E6%9C%BA%E9%83%A8%E7%BD%B2alist/">移动云手机部署alist</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/10/2023-09-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95C%E8%AF%AD%E8%A8%80/">数据类型的分析（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/10/2023-09-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/">数据类型的分析（一）</a></li></ul>
        </div>
        <div class="col-m-4">
          <h3 class="title-date">时光机：</h3>
          <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li></ul>
        </div>
        <div class="col-m-4">
          <h3 class="title-tags">标签云：</h3>
          <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 20px;">C语言</a> <a href="/tags/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" style="font-size: 10px;">C语言指针</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/WIndows/" style="font-size: 10px;">WIndows</a> <a href="/tags/alist/" style="font-size: 10px;">alist</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/" style="font-size: 10px;">外网访问</a> <a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 15px;">安卓</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 10px;">数据存储</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构算法</a> <a href="/tags/%E6%A0%BC%E6%9C%BA/" style="font-size: 10px;">格机</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%91%E6%89%8B%E6%9C%BA/" style="font-size: 10px;">移动云手机</a>
        </div>
      </div>
    </section>
    <section class="sub-footer">
      <p>
        © 2024
        <a href="/">Frost</a>. All Rights Reserved.
        By
        <a
          href="https://github.com/xiamuqingyuan/xiamuqingyuan.github.io"
          target="_blank"
          rel="nofollow"
          >Frost</a
        >.
      </p>
    </section>
  </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>
<script src="/static/1.js"></script>
<script src="/static/2.js"></script>


<script>
  var hingle = new Paul_Hingle({"copyright":true,"night":true});
</script>

  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>
